import {
  collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, writeBatch,
  query, where, orderBy, limit, onSnapshot, Timestamp, DocumentData, serverTimestamp, QueryConstraint,
  getDocsFromCache, getDocsFromServer, getDocFromCache, getDocFromServer, Query, QuerySnapshot, DocumentSnapshot
} from 'firebase/firestore';
import { db } from './firebase';
import type { Player, Match, Court, MatchHistory, Config, TournamentType, MatchStatus, TournamentConfig, Camp, MatchWithPlayers } from '@/types';

const COLLECTIONS = {
  players: 'players',
  matches: 'matches',
  courts: 'courts',
  teams: 'teams',
  team_battles: 'team_battles',
  match_history: 'match_history',
  config: 'config',
} as const;

// ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç³»ã‚¨ãƒ©ãƒ¼ã‹ã©ã†ã‹ã‚’åˆ¤å®š
function isOfflineError(error: any): boolean {
  const code = error?.code;
  const message = error?.message || '';
  return (
    code === 'unavailable' ||
    code === 'failed-precondition' ||
    message.includes('offline') ||
    message.includes('Failed to get document because the client is offline')
  );
}

/**
 * ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å–å¾—ãƒ©ãƒƒãƒ‘ãƒ¼: ã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚’è©¦ã¿ã€å¤±æ•—ã—ãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
 * ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç³»ã‚¨ãƒ©ãƒ¼ã¯çµ¶å¯¾ã«å¤–ã«æŠ•ã’ãªã„
 * ã‚µãƒ¼ãƒãƒ¼å–å¾—ã¯5ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
 */
export async function safeGetDocs<T = DocumentData>(q: Query<T>): Promise<QuerySnapshot<T>> {
  // ã¾ãšã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆ5ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
  try {
    const serverPromise = getDocsFromServer(q);
    const timeoutPromise = new Promise<never>((_, reject) => 
      setTimeout(() => reject(new Error('Server request timeout after 5s')), 5000)
    );
    
    return await Promise.race([serverPromise, timeoutPromise]);
  } catch (serverError: any) {
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ãŸã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
    const isTimeout = serverError?.message?.includes('timeout');
    if (isTimeout) {
      console.log('[safeGetDocs] ã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ(5ç§’)ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
    } else if (serverError?.code === 'unavailable' || isOfflineError(serverError)) {
      console.log('[safeGetDocs] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ¤œçŸ¥ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
    } else {
      console.warn('[safeGetDocs] ã‚µãƒ¼ãƒãƒ¼å–å¾—å¤±æ•—:', serverError?.code || serverError?.message);
    }
  }

  // ã‚µãƒ¼ãƒãƒ¼å¤±æ•—æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
  try {
    const cacheSnapshot = await getDocsFromCache(q);
    console.log('[safeGetDocs] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—æˆåŠŸ:', cacheSnapshot.size, 'ä»¶');
    return cacheSnapshot;
  } catch (cacheError: any) {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆã¯æƒ…å ±ãƒ¬ãƒ™ãƒ«ã®ãƒ­ã‚°
    console.log('[safeGetDocs] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—ã€ç©ºçµæœã‚’è¿”å´');
  }

  // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®getDocsï¼ˆã‚¨ãƒ©ãƒ¼ã¯æ¡ã‚Šã¤ã¶ã™ï¼‰
  try {
    return await getDocs(q);
  } catch (finalError: any) {
    // æœ€çµ‚çš„ãªã‚¨ãƒ©ãƒ¼ã®ã¿è­¦å‘Šã‚’å‡ºã™
    console.warn('[safeGetDocs] å…¨ã¦ã®å–å¾—æ–¹æ³•ãŒå¤±æ•—ã€ç©ºçµæœã‚’è¿”å´:', finalError?.code || finalError?.message);
    // ç©ºã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç›¸å½“ã‚’è¿”ã™ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’å¤–ã«æŠ•ã’ãªã„ï¼‰
    return {
      docs: [],
      empty: true,
      size: 0,
      metadata: { fromCache: true, hasPendingWrites: false },
      forEach: () => {},
      docChanges: () => [],
    } as unknown as QuerySnapshot<T>;
  }
}

/**
 * å˜ä¸€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå–å¾—ãƒ©ãƒƒãƒ‘ãƒ¼: ã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚’è©¦ã¿ã€å¤±æ•—ã—ãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
 * ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç³»ã‚¨ãƒ©ãƒ¼ã¯çµ¶å¯¾ã«å¤–ã«æŠ•ã’ãªã„
 * ã‚µãƒ¼ãƒãƒ¼å–å¾—ã¯5ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
 */
export async function safeGetDoc(docRef: any): Promise<DocumentSnapshot> {
  // ã¾ãšã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆ5ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
  try {
    const serverPromise = getDocFromServer(docRef);
    const timeoutPromise = new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Server request timeout after 5s')), 5000)
    );

    return await Promise.race([serverPromise, timeoutPromise]);
  } catch (serverError: any) {
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ãŸã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
    const isTimeout = serverError?.message?.includes('timeout');
    if (isTimeout) {
      console.log('[safeGetDoc] ã‚µãƒ¼ãƒãƒ¼å–å¾—ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ(5ç§’)ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
    } else if (serverError?.code === 'unavailable' || isOfflineError(serverError)) {
      console.log('[safeGetDoc] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ¤œçŸ¥ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
    } else {
      console.log('[safeGetDoc] ã‚µãƒ¼ãƒãƒ¼å–å¾—å¤±æ•—:', serverError?.code || serverError?.message);
    }
  }

  // ã‚µãƒ¼ãƒãƒ¼å¤±æ•—æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
  try {
    const cacheSnapshot = await getDocFromCache(docRef);
    console.log('[safeGetDoc] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—æˆåŠŸ');
    return cacheSnapshot;
  } catch (cacheError: any) {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆã¯æƒ…å ±ãƒ¬ãƒ™ãƒ«ã®ãƒ­ã‚°
    console.log('[safeGetDoc] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—');
  }

  // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®getDocï¼ˆã‚¨ãƒ©ãƒ¼ã¯æ¡ã‚Šã¤ã¶ã™ï¼‰
  try {
    return await getDoc(docRef);
  } catch (finalError: any) {
    // æœ€çµ‚çš„ãªã‚¨ãƒ©ãƒ¼ã¯è­¦å‘Šã§ã¯ãªããƒ­ã‚°ã«
    console.log('[safeGetDoc] å…¨ã¦ã®å–å¾—æ–¹æ³•ãŒå¤±æ•—ã€å­˜åœ¨ã—ãªã„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã—ã¦æ‰±ã†');
    // å­˜åœ¨ã—ãªã„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã—ã¦æ‰±ã†ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’å¤–ã«æŠ•ã’ãªã„ï¼‰
    return {
      exists: () => false,
      data: () => undefined,
      id: docRef.id,
      ref: docRef,
      metadata: { fromCache: false, hasPendingWrites: false },
    } as unknown as DocumentSnapshot;
  }
}


// Generic helpers
export async function getAllDocuments<T>(collectionName: string, constraints: QueryConstraint[] = []): Promise<T[]> {
  try {
    const collectionRef = collection(db, collectionName);
    const q = constraints.length > 0 ? query(collectionRef, ...constraints) : query(collectionRef);
    const querySnapshot = await safeGetDocs(q);
    return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as T[];
  } catch (error) {
    console.warn(`[getAllDocuments] ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã€ç©ºé…åˆ—ã‚’è¿”å´ (${collectionName}):`, error);
    return [];
  }
}

export async function setDocument<T extends { id: string }>(collectionName: string, data: T): Promise<boolean> {
  try {
    const { id, ...docData } = data;
    if (!id) {
      console.error(`Error: Missing ID for setDocument in ${collectionName}`);
      return false;
    }
    const docRef = doc(db, collectionName, id);
    await setDoc(docRef, docData);
    return true;
  } catch (error) {
    console.error(`Error setting document in ${collectionName}:`, error);
    return false;
  }
}

export async function getDocument<T>(collectionName: string, docId: string): Promise<T | null> {
  try {
    if (!docId) return null;
    const docRef = doc(db, collectionName, docId);
    const docSnap = await safeGetDoc(docRef);
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as T;
    }
    return null;
  } catch (error) {
    console.error(`Error getting document from ${collectionName}:`, error);
    return null;
  }
}

export async function updateDocument(collectionName: string, docId: string, updates: Record<string, unknown>): Promise<void> {
  if (!docId) {
    console.error(`Error: Missing ID for updateDocument in ${collectionName}`);
    return;
  }
  const docRef = doc(db, collectionName, docId);
  const docSnap = await safeGetDoc(docRef);
  if (!docSnap.exists()) {
    return;
  }
  await updateDoc(docRef, { ...updates, updated_at: Timestamp.now() });
}

export async function deleteDocument(collectionName: string, docId: string): Promise<boolean> {
  try {
    if (!docId) {
      return false;
    }
    const docRef = doc(db, collectionName, docId);
    await deleteDoc(docRef);
    return true;
  } catch (error) {
    console.error(`Error deleting document from ${collectionName}:`, error);
    return false;
  }
}

export function subscribeToCollection<T>(collectionName: string, callback: (data: T[]) => void, constraints: QueryConstraint[] = []) {
  const collectionRef = collection(db, collectionName);
  const q = constraints.length > 0 ? query(collectionRef, ...constraints) : collectionRef;
  return onSnapshot(q, { includeMetadataChanges: true }, (snapshot) => {
    // hasPendingWritesã‚„fromCacheã«é–¢ä¿‚ãªãã€å¸¸ã«UIã‚’å³åº§ã«æ›´æ–°
    const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as T[];
    callback(data);
  }, (error: any) => {
    if (isOfflineError(error)) {
      console.warn(`[subscribeToCollection] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ (${collectionName}):`, error?.code || error?.message);
    } else {
      console.error(`Error in ${collectionName} listener:`, error);
    }
  });
}

export function subscribeToDocument<T>(collectionName: string, docId: string, callback: (data: T | null) => void) {
  if (!docId) {
    callback(null);
    return () => { }; // Return empty unsubscribe function
  }
  const docRef = doc(db, collectionName, docId);
  return onSnapshot(docRef, { includeMetadataChanges: true }, (snapshot) => {
    // hasPendingWritesã‚„fromCacheã«é–¢ä¿‚ãªãã€å¸¸ã«UIã‚’å³åº§ã«æ›´æ–°
    if (snapshot.exists()) {
      const data = { id: snapshot.id, ...snapshot.data() } as T;
      callback(data);
    } else {
      callback(null);
    }
  }, (error: any) => {
    if (isOfflineError(error)) {
      console.warn(`[subscribeToDocument] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ (${collectionName}/${docId}):`, error?.code || error?.message);
    } else {
      console.error(`Error in ${collectionName}/${docId} listener:`, error);
    }
  });
}

// Court functions
export async function getAllCourts(): Promise<Court[]> {
  return getAllDocuments<Court>(COLLECTIONS.courts, [orderBy('number')]);
}

export function subscribeToCourts(callback: (courts: Court[]) => void, campId?: string) {
  const constraints = campId
    ? [where('campId', '==', campId), orderBy('number')]
    : [orderBy('number')];
  return subscribeToCollection<Court>(COLLECTIONS.courts, callback, constraints);
}

export async function initializeCourts(courtCount: number, campId: string): Promise<boolean> {
  try {
    const courts: Court[] = [];
    for (let i = 1; i <= courtCount; i++) {
      courts.push({
        id: `court_${campId}_${i}`,
        number: i,
        preferred_gender: i <= Math.floor(courtCount / 2) ? 'male' : 'female',
        current_match_id: null,
        is_active: true,
        campId
      });
    }
    for (const court of courts) { await setDocument(COLLECTIONS.courts, court); }
    return true;
  } catch (error) {
    console.error('Error initializing courts:', error);
    return false;
  }
}

export async function initializeConfig(): Promise<boolean> {
  try {
    const config: Config = {
      auto_dispatch_enabled: false,
      current_phase: null,
      tournament_date: Timestamp.now(),
      last_operation: null,
    };
    await setDoc(doc(db, COLLECTIONS.config, 'system'), config);
    return true;
  } catch (error) {
    console.error('Error initializing config:', error);
    return false;
  }
}

// Player functions
export async function getAllPlayers(campId?: string): Promise<Player[]> {
  const constraints = campId
    ? [where('campId', '==', campId), orderBy('name')]
    : [orderBy('name')];
  return getAllDocuments<Player>(COLLECTIONS.players, constraints);
}

export async function importPlayers(players: Omit<Player, 'id'>[]): Promise<{ success: number; errors: string[]; }> {
  const errors: string[] = [];
  
  if (players.length === 0) {
    return { success: 0, errors: [] };
  }

  try {
    const batch = writeBatch(db);
    const timestamp = Date.now();

    for (let i = 0; i < players.length; i++) {
      const player = players[i];
      const safeName = player.name.replace(/\s+/g, '_');
      const id = `player_${timestamp}_${i}_${safeName}`;
      const docRef = doc(db, COLLECTIONS.players, id);
      batch.set(docRef, player);
    }

    await batch.commit();
    return { success: players.length, errors: [] };
  } catch (error) {
    console.error('[importPlayers] ãƒãƒƒãƒä¿å­˜å¤±æ•—:', error);
    errors.push(`ä¸€æ‹¬ä¿å­˜ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    return { success: 0, errors };
  }
}

export async function deleteAllPlayers(): Promise<boolean> {
  try {
    const players = await getAllPlayers();
    for (const player of players) { await deleteDocument(COLLECTIONS.players, player.id); }
    return true;
  } catch (error) {
    console.error('Error deleting all players:', error);
    return false;
  }
}

// Match functions
export async function createMatches(matches: Omit<Match, 'id'>[]): Promise<{ success: number; errors: string[]; }> {
  const errors: string[] = [];

  if (matches.length === 0) {
    return { success: 0, errors: [] };
  }

  try {
    const timestamp = Date.now();
    const BATCH_SIZE = 500;

    // 500ä»¶ã”ã¨ã«ãƒãƒƒãƒã‚’åˆ†å‰²ã—ã¦ä¿å­˜
    for (let batchStart = 0; batchStart < matches.length; batchStart += BATCH_SIZE) {
      const batch = writeBatch(db);
      const batchEnd = Math.min(batchStart + BATCH_SIZE, matches.length);

      for (let i = batchStart; i < batchEnd; i++) {
        const match = matches[i];
        const id = `match_${timestamp}_${i}`;
        const docRef = doc(db, COLLECTIONS.matches, id);
        batch.set(docRef, {
          id,
          ...match,
          created_at: Timestamp.now(),
          updated_at: Timestamp.now()
        });
      }

      await batch.commit();
    }

    return { success: matches.length, errors: [] };
  } catch (error) {
    console.error('[createMatches] ãƒãƒƒãƒä¿å­˜å¤±æ•—:', error);
    errors.push(`ä¸€æ‹¬ä¿å­˜ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    return { success: 0, errors };
  }
}

export async function getAllMatches(campId?: string): Promise<Match[]> {
  const constraints = campId
    ? [where('campId', '==', campId), orderBy('created_at')]
    : [orderBy('created_at')];
  return getAllDocuments<Match>(COLLECTIONS.matches, constraints);
}

export async function getMatchesByTournament(tournamentType: TournamentType, campId?: string): Promise<Match[]> {
  const constraints = campId
    ? [
        where('campId', '==', campId),
        where('tournament_type', '==', tournamentType),
        orderBy('round'),
        orderBy('created_at')
      ]
    : [
        where('tournament_type', '==', tournamentType),
        orderBy('round'),
        orderBy('created_at')
      ];
  return getAllDocuments<Match>(COLLECTIONS.matches, constraints);
}

export function subscribeToMatchesByTournament(
  tournamentType: TournamentType,
  callback: (matches: Match[]) => void,
  campId?: string
) {
  const constraints = campId
    ? [
        where('campId', '==', campId),
        where('tournament_type', '==', tournamentType),
        orderBy('round'),
        orderBy('created_at')
      ]
    : [
        where('tournament_type', '==', tournamentType),
        orderBy('round'),
        orderBy('created_at')
      ];
  return subscribeToCollection<Match>(COLLECTIONS.matches, callback, constraints);
}

export function subscribeToPlayers(callback: (players: Player[]) => void, campId?: string) {
  const constraints = campId ? [where('campId', '==', campId)] : [];
  return subscribeToCollection<Player>(COLLECTIONS.players, callback, constraints);
}

export async function startMatch(matchId: string): Promise<void> {
  await updateDocument('matches', matchId, {
    status: 'playing',
    started_at: Timestamp.now()
  });
}

export async function updateMatchResult(
  matchId: string,
  scoreP1: number,
  scoreP2: number,
  winnerId: string
): Promise<boolean> {
  try {
    if (!matchId) return false;

    // ç¾åœ¨ã®è©¦åˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const currentMatch = await getDocument<Match>(COLLECTIONS.matches, matchId);
    if (!currentMatch) return false;

    // è©¦åˆçµæœã‚’æ›´æ–°
    const matchRef = doc(db, COLLECTIONS.matches, matchId);
    await updateDoc(matchRef, {
      score_p1: scoreP1,
      score_p2: scoreP2,
      winner_id: winnerId,
      status: 'completed',
      end_time: Timestamp.now(),
      updated_at: Timestamp.now(),
    });

    // æ¬¡ã®è©¦åˆãŒã‚ã‚‹å ´åˆã€å‹è€…ã‚’è¨­å®š
    if (currentMatch.next_match_id && currentMatch.next_match_position) {
      const nextMatchRef = doc(db, COLLECTIONS.matches, currentMatch.next_match_id);
      const isWinner1 = winnerId === currentMatch.player1_id;

      // å‹è€…ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’å–å¾—ï¼ˆãƒ€ãƒ–ãƒ«ã‚¹ã®å ´åˆã¯ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚‚ï¼‰
      const winnerMainId = isWinner1 ? currentMatch.player1_id : currentMatch.player2_id;
      const winnerPartnerId = isWinner1 ? currentMatch.player3_id : currentMatch.player4_id;

      // æ¬¡ã®è©¦åˆã§ã®ä½ç½®ã«å¿œã˜ã¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®š
      const nextMatchUpdate: Record<string, unknown> = {
        updated_at: Timestamp.now(),
      };

      if (currentMatch.next_match_position === 1) {
        // ä¸Šå´ï¼ˆplayer1å´ï¼‰ã«è¨­å®š
        nextMatchUpdate.player1_id = winnerMainId;
        if (winnerPartnerId) {
          nextMatchUpdate.player3_id = winnerPartnerId;
        }
      } else if (currentMatch.next_match_position === 2) {
        // ä¸‹å´ï¼ˆplayer2å´ï¼‰ã«è¨­å®š
        nextMatchUpdate.player2_id = winnerMainId;
        if (winnerPartnerId) {
          nextMatchUpdate.player4_id = winnerPartnerId;
        }
      }

      await updateDoc(nextMatchRef, nextMatchUpdate);
    }

    return true;
  } catch (error) {
    console.error('Error updating match result:', error);
    return false;
  }
}

export async function getActiveMatches(): Promise<Match[]> {
  return getAllDocuments<Match>(COLLECTIONS.matches, [
    where('status', 'in', ['waiting', 'calling', 'playing']),
    orderBy('created_at')
  ]);
}

export async function updateMatchStatus(
  matchId: string,
  status: MatchStatus
): Promise<boolean> {
  try {
    if (!matchId) return false;
    const matchRef = doc(db, COLLECTIONS.matches, matchId);
    const updateData: Record<string, unknown> = {
      status,
      updated_at: Timestamp.now(),
    };

    if (status === 'playing' && !updateData.start_time) {
      updateData.start_time = Timestamp.now();
    }

    await updateDoc(matchRef, updateData);
    return true;
  } catch (error) {
    console.error('Error updating match status:', error);
    return false;
  }
}

export async function getPlayerById(playerId: string): Promise<Player | null> {
  try {
    if (!playerId) return null;
    const docRef = doc(db, COLLECTIONS.players, playerId);
    const docSnap = await safeGetDoc(docRef);
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as Player;
    }
    return null;
  } catch (error) {
    console.error('Error getting player:', error);
    return null;
  }
}

export function subscribeToActiveMatches(callback: (matches: Match[]) => void, campId?: string) {
  const constraints = [
    where('status', 'in', ['waiting', 'calling', 'playing']),
    orderBy('created_at')
  ];
  if (campId) {
    constraints.unshift(where('campId', '==', campId));
  }
  return subscribeToCollection<Match>(COLLECTIONS.matches, callback, constraints);
}

export function subscribeToCompletedMatches(callback: (matches: Match[]) => void, campId?: string) {
  const constraints = [
    where('status', '==', 'completed'),
    orderBy('updated_at', 'desc')
  ];
  if (campId) {
    constraints.unshift(where('campId', '==', campId));
  }
  return subscribeToCollection<Match>(COLLECTIONS.matches, callback, constraints);
}

export async function resetMatchResult(matchId: string): Promise<boolean> {
  try {
    if (!matchId) return false;

    const currentMatch = await getDocument<Match>(COLLECTIONS.matches, matchId);
    if (!currentMatch) return false;

    // æ¬¡ã®è©¦åˆã‹ã‚‰å‹è€…æƒ…å ±ã‚’å‰Šé™¤
    if (currentMatch.next_match_id && currentMatch.next_match_position) {
      const nextMatchRef = doc(db, COLLECTIONS.matches, currentMatch.next_match_id);
      const nextMatchUpdate: any = { updated_at: Timestamp.now() };

      if (currentMatch.next_match_position === 1) {
        nextMatchUpdate.player1_id = '';
        if (currentMatch.player3_id) nextMatchUpdate.player3_id = '';
      } else if (currentMatch.next_match_position === 2) {
        nextMatchUpdate.player2_id = '';
        if (currentMatch.player4_id) nextMatchUpdate.player4_id = '';
      }

      await updateDoc(nextMatchRef, nextMatchUpdate);
    }

    // è©¦åˆã‚’æœªå®Ÿæ–½ã«æˆ»ã™
    const matchRef = doc(db, COLLECTIONS.matches, matchId);
    await updateDoc(matchRef, {
      score_p1: 0,
      score_p2: 0,
      winner_id: null,
      status: 'waiting',
      end_time: null,
      is_walkover: false,
      walkover_winner: null,
      updated_at: Timestamp.now(),
    });

    return true;
  } catch (error) {
    console.error('Error resetting match:', error);
    return false;
  }
}

export async function recordWalkover(
  matchId: string,
  winnerSide: 1 | 2
): Promise<boolean> {
  try {
    if (!matchId) return false;

    const currentMatch = await getDocument<Match>(COLLECTIONS.matches, matchId);
    if (!currentMatch) return false;

    const winnerId = winnerSide === 1 ? currentMatch.player1_id : currentMatch.player2_id;

    // è©¦åˆã‚’æ£„æ¨©ã¨ã—ã¦å®Œäº†
    const matchRef = doc(db, COLLECTIONS.matches, matchId);
    await updateDoc(matchRef, {
      is_walkover: true,
      walkover_winner: winnerSide,
      winner_id: winnerId,
      status: 'completed',
      end_time: Timestamp.now(),
      updated_at: Timestamp.now(),
    });

    // æ¬¡ã®è©¦åˆãŒã‚ã‚‹å ´åˆã€å‹è€…ã‚’è¨­å®š
    if (currentMatch.next_match_id && currentMatch.next_match_position) {
      const nextMatchRef = doc(db, COLLECTIONS.matches, currentMatch.next_match_id);
      const winnerMainId = winnerSide === 1 ? currentMatch.player1_id : currentMatch.player2_id;
      const winnerPartnerId = winnerSide === 1 ? currentMatch.player3_id : currentMatch.player4_id;

      const nextMatchUpdate: any = { updated_at: Timestamp.now() };

      if (currentMatch.next_match_position === 1) {
        nextMatchUpdate.player1_id = winnerMainId;
        if (winnerPartnerId) nextMatchUpdate.player3_id = winnerPartnerId;
      } else if (currentMatch.next_match_position === 2) {
        nextMatchUpdate.player2_id = winnerMainId;
        if (winnerPartnerId) nextMatchUpdate.player4_id = winnerPartnerId;
      }

      await updateDoc(nextMatchRef, nextMatchUpdate);
    }

    return true;
  } catch (error) {
    console.error('Error recording walkover:', error);
    return false;
  }
}


// Phase 9: Tournament Config CRUD
export async function getTournamentConfigs(campId?: string): Promise<TournamentConfig[]> {
  const constraints = campId ? [where('campId', '==', campId)] : [];
  return getAllDocuments<TournamentConfig>('tournament_configs', constraints);
}

export async function getTournamentConfig(id: string): Promise<TournamentConfig | null> {
  return getDocument<TournamentConfig>('tournament_configs', id);
}

export async function createTournamentConfig(config: Omit<TournamentConfig, 'id' | 'created_at'>): Promise<string> {
  const docRef = doc(collection(db, 'tournament_configs'));
  const newConfig: TournamentConfig = {
    ...config,
    id: docRef.id,
    created_at: Timestamp.now()
  };
  await setDoc(docRef, newConfig);
  return docRef.id;
}

export async function updateTournamentConfig(id: string, updates: Partial<TournamentConfig>): Promise<void> {
  return updateDocument('tournament_configs', id, updates);
}

export async function deleteTournamentConfig(id: string): Promise<boolean> {
  return deleteDocument('tournament_configs', id);
}

export function subscribeToTournamentConfigs(callback: (configs: TournamentConfig[]) => void, campId?: string) {
  const constraints = campId ? [where('campId', '==', campId)] : [];
  return subscribeToCollection<TournamentConfig>('tournament_configs', callback, constraints);
}

export async function getMatchWithPlayers(matchId: string): Promise<MatchWithPlayers | null> {
  const match = await getDocument<Match>(COLLECTIONS.matches, matchId);
  if (!match) return null;

  const player1 = await getPlayerById(match.player1_id);
  const player2 = await getPlayerById(match.player2_id);
  if (!player1 || !player2) return null;

  const result: MatchWithPlayers = { ...match, player1, player2 };

  if (match.player3_id) {
    const player3 = await getPlayerById(match.player3_id);
    if (player3) result.player3 = player3;
  }

  if (match.player4_id) {
    const player4 = await getPlayerById(match.player4_id);
    if (player4) result.player4 = player4;
  }

  return result;
}

// ğŸ‘‡ å¿…è¦ãªimportãŒè¶³ã‚Šãªã„å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã«è¿½åŠ ã—ã¦ãã ã•ã„
// import { collection, doc, getDocs, getDoc, setDoc, updateDoc, query, where, orderBy, serverTimestamp } from "firebase/firestore";
// import { db } from "./firebase";
// import type { Camp, Config } from "@/types";

// ==========================================
// âœ… Phase 10: åˆå®¿ (Camp) ç®¡ç†ç”¨ãƒ»æ–°æ©Ÿèƒ½
// ==========================================

/**
 * æ–°ã—ã„åˆå®¿ã‚’ä½œæˆã™ã‚‹
 */
export const createCamp = async (title: string, courtCount: number = 6, ownerId?: string) => {
  try {
    const campsRef = collection(db, 'camps');
    const newCampRef = doc(campsRef); // IDã‚’è‡ªå‹•ç”Ÿæˆ

    const newCamp: Camp = {
      id: newCampRef.id,
      title: title,
      court_count: courtCount,
      status: 'setup', // æœ€åˆã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­
      created_at: serverTimestamp() as any,
      owner_id: ownerId, // ä½œæˆè€…ã®UIDã‚’ä¿å­˜
      config: {
        default_match_points: 15, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ15ç‚¹
      },
    };

    console.log('[createCamp] æ–°è¦åˆå®¿ä½œæˆ:', { title, owner_id: ownerId, id: newCampRef.id });
    await setDoc(newCampRef, newCamp);
    return newCampRef.id;
  } catch (error) {
    console.error("Error creating camp:", error);
    return null;
  }
};

/**
 * ã™ã¹ã¦ã®åˆå®¿ã‚’å–å¾—ã™ã‚‹
 */
export const getAllCamps = async (currentUserId?: string): Promise<Camp[]> => {
  try {
    const campsRef = collection(db, 'camps');
    // ä½œæˆæ—¥é †ã«ä¸¦ã¹ã‚‹ï¼ˆæ–°ã—ã„ã‚‚ã®ãŒä¸Šï¼‰
    const q = query(campsRef, orderBy('created_at', 'desc'));
    const snapshot = await safeGetDocs(q);

    const camps = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Camp));

    // ãƒ‡ãƒãƒƒã‚°: owner_idã¨ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼UIDã‚’æ¯”è¼ƒ
    if (currentUserId) {
      console.log('[getAllCamps] ç¾åœ¨ã®ãƒ­ã‚°ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼UID:', currentUserId);
      camps.forEach(camp => {
        const match = camp.owner_id === currentUserId;
        console.log('[getAllCamps]', {
          camp_id: camp.id,
          camp_title: camp.title,
          owner_id: camp.owner_id || '(æœªè¨­å®š)',
          current_user: currentUserId,
          match: match ? 'âœ“' : 'âœ—'
        });
      });
    }

    // æ³¨: é–‹ç™ºä¸­ã¯owner_idæœªè¨­å®šã®åˆå®¿ã‚‚å…¨ã¦è¡¨ç¤º
    // æœ¬ç•ªç’°å¢ƒã§ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’æ¤œè¨
    // ä¾‹: return camps.filter(c => !c.owner_id || c.owner_id === currentUserId);
    return camps;
  } catch (error) {
    console.error("Error getting all camps:", error);
    return [];
  }
};

/**
 * ç‰¹å®šã®åˆå®¿ã‚’ã€Œã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼ˆé–‹å‚¬ä¸­ï¼‰ã€ã«ã™ã‚‹
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç”»é¢ã«ã¯ã“ã®åˆå®¿ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹
 */
export const activateCamp = async (campId: string) => {
  try {
    // 1. æŒ‡å®šã•ã‚ŒãŸåˆå®¿ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ active ã«ã™ã‚‹
    // (ä»–ã‚’ archived ã«ã™ã‚‹ã‹ã¯é‹ç”¨æ¬¡ç¬¬ã ãŒã€ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–IDã‚’Configã«è¨˜éŒ²ã™ã‚‹æ–¹å¼ã‚’ã¨ã‚‹)

    // Config/system ã« activeCampId ã‚’æ›¸ãè¾¼ã‚€
    const configRef = doc(db, 'config', 'system');
    await setDoc(configRef, { activeCampId: campId }, { merge: true });

    // åˆå®¿è‡ªä½“ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚‚æ›´æ–°
    await updateDocument('camps', campId, { status: 'active' });

    return true;
  } catch (error) {
    console.error("Error activating camp:", error);
    return false;
  }
};

/**
 * ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªåˆå®¿ã®IDã‚’å–å¾—ã™ã‚‹
 */
export const getActiveCampId = async (): Promise<string | null> => {
  try {
    const config = await getDocument<Config>('config', 'system');
    return config?.activeCampId || null;
  } catch (error) {
    console.error("Error getting active camp ID:", error);
    return null;
  }
};

/**
 * åˆå®¿ç”¨ã®ã‚³ãƒ¼ãƒˆã‚’åˆæœŸåŒ–ã™ã‚‹
 * (æ—¢å­˜ã® initializeCourts ã¯6é¢å›ºå®šã ã£ãŸãŒã€ã“ã¡ã‚‰ã¯å¯å¤‰å¯¾å¿œ)
 */
export const archiveCamp = async (campId: string) => {
  try {
    const campRef = doc(db, 'camps', campId);
    await updateDoc(campRef, { status: 'archived' });
  } catch (error) {
    console.error('Error archiving camp:', error);
    throw error;
  }
};

export const unarchiveCamp = async (campId: string) => {
  try {
    const campRef = doc(db, 'camps', campId);
    await updateDoc(campRef, { status: 'setup' });
  } catch (error) {
    console.error('Error unarchiving camp:', error);
    throw error;
  }
};

export const deleteCamp = async (campId: string) => {
  try {
    const campRef = doc(db, 'camps', campId);
    await deleteDoc(campRef);
  } catch (error) {
    console.error('Error deleting camp:', error);
    throw error;
  }
};

/**
 * åˆå®¿ã«ç´ã¥ãå…¨ãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨å‰Šé™¤ã™ã‚‹
 * - Players
 * - Matches
 * - Courts
 * - Tournament Configs
 * - Campè‡ªä½“
 */
export const deleteCompleteCampData = async (campId: string): Promise<{
  success: boolean;
  deletedCounts: {
    players: number;
    matches: number;
    courts: number;
    tournamentConfigs: number;
  };
  errors: string[];
}> => {
  const errors: string[] = [];
  const deletedCounts = {
    players: 0,
    matches: 0,
    courts: 0,
    tournamentConfigs: 0,
  };

  try {
    // 1. é¸æ‰‹ï¼ˆPlayersï¼‰ã®å‰Šé™¤
    try {
      const playersQuery = query(collection(db, 'players'), where('campId', '==', campId));
      const playersSnapshot = await safeGetDocs(playersQuery);

      if (playersSnapshot.docs.length > 0) {
        const playersBatch = writeBatch(db);
        playersSnapshot.docs.forEach(doc => {
          playersBatch.delete(doc.ref);
        });
        await playersBatch.commit();
        deletedCounts.players = playersSnapshot.docs.length;
      }
    } catch (error) {
      errors.push(`é¸æ‰‹ã®å‰Šé™¤ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    }

    // 2. è©¦åˆï¼ˆMatchesï¼‰ã®å‰Šé™¤
    try {
      const matchesQuery = query(collection(db, 'matches'), where('campId', '==', campId));
      const matchesSnapshot = await safeGetDocs(matchesQuery);

      if (matchesSnapshot.docs.length > 0) {
        const matchesBatch = writeBatch(db);
        matchesSnapshot.docs.forEach(doc => {
          matchesBatch.delete(doc.ref);
        });
        await matchesBatch.commit();
        deletedCounts.matches = matchesSnapshot.docs.length;
      }
    } catch (error) {
      errors.push(`è©¦åˆã®å‰Šé™¤ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    }

    // 3. ã‚³ãƒ¼ãƒˆï¼ˆCourtsï¼‰ã®å‰Šé™¤
    try {
      const courtsQuery = query(collection(db, 'courts'), where('campId', '==', campId));
      const courtsSnapshot = await safeGetDocs(courtsQuery);

      if (courtsSnapshot.docs.length > 0) {
        const courtsBatch = writeBatch(db);
        courtsSnapshot.docs.forEach(doc => {
          courtsBatch.delete(doc.ref);
        });
        await courtsBatch.commit();
        deletedCounts.courts = courtsSnapshot.docs.length;
      }
    } catch (error) {
      errors.push(`ã‚³ãƒ¼ãƒˆã®å‰Šé™¤ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    }

    // 4. ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆè¨­å®šï¼ˆTournament Configsï¼‰ã®å‰Šé™¤
    try {
      const configsQuery = query(collection(db, 'tournament_configs'), where('campId', '==', campId));
      const configsSnapshot = await safeGetDocs(configsQuery);

      if (configsSnapshot.docs.length > 0) {
        const configsBatch = writeBatch(db);
        configsSnapshot.docs.forEach(doc => {
          configsBatch.delete(doc.ref);
        });
        await configsBatch.commit();
        deletedCounts.tournamentConfigs = configsSnapshot.docs.length;
      }
    } catch (error) {
      errors.push(`ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆè¨­å®šã®å‰Šé™¤ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    }

    // 5. åˆå®¿æœ¬ä½“ï¼ˆCampï¼‰ã®å‰Šé™¤
    try {
      const campRef = doc(db, 'camps', campId);
      await deleteDoc(campRef);
    } catch (error) {
      errors.push(`åˆå®¿æœ¬ä½“ã®å‰Šé™¤ã«å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`);
    }

    return {
      success: errors.length === 0,
      deletedCounts,
      errors
    };
  } catch (error) {
    console.error('Error in deleteCompleteCampData:', error);
    return {
      success: false,
      deletedCounts,
      errors: [...errors, `äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : String(error)}`]
    };
  }
};

export const deleteAllMatches = async (campId: string) => {
  try {
    const matchesQuery = query(collection(db, 'matches'), where('campId', '==', campId));
    const snapshot = await safeGetDocs(matchesQuery);
    const batch = snapshot.docs.reduce((b, doc) => {
      b.delete(doc.ref);
      return b;
    }, writeBatch(db));
    await batch.commit();
  } catch (error) {
    console.error('Error deleting all matches:', error);
    throw error;
  }
};

export const deleteTournamentMatches = async (campId: string, eventType: string, division: number) => {
  try {
    const matchesQuery = query(
      collection(db, 'matches'),
      where('campId', '==', campId),
      where('tournament_type', '==', eventType),
      where('division', '==', division)
    );
    const snapshot = await safeGetDocs(matchesQuery);
    if (snapshot.docs.length === 0) return;
    const batch = writeBatch(db);
    snapshot.docs.forEach(doc => batch.delete(doc.ref));
    await batch.commit();
  } catch (error) {
    console.warn('[deleteTournamentMatches] ã‚¨ãƒ©ãƒ¼:', error);
  }
};

export const setupCampCourts = async (courtCount: number) => {
  try {
    // æ—¢å­˜ã®ã‚³ãƒ¼ãƒˆã‚’å‰Šé™¤ã™ã‚‹å‡¦ç†ãŒå¿…è¦ã ãŒã€
    // Campã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã¯ã€ŒCampã”ã¨ã«ã‚³ãƒ¼ãƒˆã‚’æŒã¤ã€ã‹ã€Œç‰©ç†ã‚³ãƒ¼ãƒˆã¯å…±æœ‰ã™ã‚‹ã‹ã€ã®åˆ¤æ–­ãŒå¿…è¦ã€‚
    // ä»Šå›ã¯ã€Œç‰©ç†ã‚³ãƒ¼ãƒˆã¯å…±æœ‰ï¼ˆä¸Šæ›¸ãï¼‰ã€ã¨ã™ã‚‹ï¼ˆPhase 10ä»•æ§˜ï¼‰

    // ä¸€æ—¦å…¨ã‚³ãƒ¼ãƒˆå‰Šé™¤ã¯ã›ãšã€ä¸Šæ›¸ãã§å¯¾å¿œ
    // ä½™åˆ†ãªã‚³ãƒ¼ãƒˆãŒã‚ã‚‹å ´åˆã¯å‰Šé™¤ãŒå¿…è¦ã ãŒã€ã¾ãšã¯æŒ‡å®šæ•°åˆ†ã‚’ä½œæˆ/æ›´æ–°

    for (let i = 1; i <= courtCount; i++) {
      const courtId = `court_${i}`;
      const courtRef = doc(db, 'courts', courtId);

      // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ãƒãƒ¼ã‚¸ã—ãªã„ã¨ã€é€²è¡Œä¸­ã®è©¦åˆãŒæ¶ˆãˆã‚‹æã‚ŒãŒã‚ã‚‹ãŒ
      // ã€Œåˆå®¿åˆ‡ã‚Šæ›¿ãˆæ™‚ã€å‰æãªã®ã§ä¸Šæ›¸ãã§ãƒªã‚»ãƒƒãƒˆã™ã‚‹
      await setDoc(courtRef, {
        id: courtId,
        number: i,
        // 1-3ã¯ç”·å­å„ªå…ˆã€4ä»¥é™ã¯å¥³å­å„ªå…ˆï¼ˆç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
        preferred_gender: i <= (courtCount / 2) ? 'male' : 'female',
        status: 'vacant',
        match: null,
        is_active: true
      });
    }

    // ã‚‚ã—æ—¢å­˜ã®ã‚³ãƒ¼ãƒˆæ•°ãŒæ–°ã—ã„è¨­å®šã‚ˆã‚Šå¤šã‹ã£ãŸå ´åˆï¼ˆä¾‹: 6é¢â†’4é¢ï¼‰ã€
    // court_5, court_6 ã‚’ç„¡åŠ¹åŒ–ã¾ãŸã¯å‰Šé™¤ã™ã‚‹å‡¦ç†ãŒå¿…è¦
    // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ã€Œis_active: falseã€ã«ã™ã‚‹å‡¦ç†ã‚’å…¥ã‚Œã‚‹ã¨å®‰å…¨
    // (å®Ÿè£…çœç•¥: é‹ç”¨ã§ã‚«ãƒãƒ¼)

    return true;
  } catch (error) {
    console.error("Error setting up camp courts:", error);
    return false;
  }
};

